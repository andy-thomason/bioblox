//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public class AtomConnection
	{
		public PDB_mesh[] molecules;
		public int[] atomIds;
		public bool isActive;
		public AtomConnection()
		{
			molecules = new PDB_mesh[2] ;
			atomIds = new int[2] ;
			isActive = false;
		}

		public AtomConnection (PDB_mesh mol1,PDB_mesh mol2, int at1, int at2)
		{
			molecules = new PDB_mesh[2] {mol1, mol2};
			atomIds = new int[2] {at1, at2};
			isActive = false;
		}

		virtual public void Update(float dampingFactor, float force, float minDist)
		{}
		virtual public void Draw()
		{}
	}

	public class Rope:AtomConnection
	{
		public class Point
		{
			public Point()
			{
				force = vel = pos = Vector3.zero;
				invMass = 1;
			}

			public Vector3 pos;
			public Vector3 vel;
			public Vector3 force;
			public float invMass;  

			public void FixedUpdate(float friction)
			{
				vel += force;
				force = Vector3.zero;

				pos += vel * Time.fixedDeltaTime * invMass;
				vel *= friction;
			}
		}

		public class Spring
		{
			Point point1;
			Point point2;
			float springVal;
			public Spring(Point a, Point b, float val)
			{
				point1 = a;
				point2 = b;
				springVal = val;
			}

			public void FixedUpdate(float springLength)
			{
				Vector3 firstToSecond = point2.pos - point1.pos;

				//if the distance is too long
				if (point1.invMass != 0 || point2.invMass !=0) { 
					Vector3 springForce = firstToSecond.normalized * (firstToSecond.magnitude - springLength) * springVal;

					float totalMass = point1.invMass + point2.invMass;

					point1.force +=springForce * (point1.invMass / totalMass);
					point2.force -=springForce * (point2.invMass / totalMass);
				}
			}
		}


		List<Point> points = new List<Point>();
		List<Spring> springs = new List<Spring>();

		public Rope(PDB_mesh mol1,PDB_mesh mol2, int at1, int at2): base(mol1,mol2,at1,at2)
		{

		}

		public Rope()
		{
			Init ();
		}

		void Init()
		{
			int numPoints = 10;
			for (int i=0; i < numPoints; ++i) {
				float div = (float)i / numPoints;
				Point potentialPoint = new Point();
				if(i==0 || i == numPoints -1)
				{
					potentialPoint.invMass = 0;
				}
				if (i > 0) {
					springs.Add(new Spring(points[i-1],potentialPoint,8.0f));
					//make a spring
				}
				potentialPoint.pos = Vector3.zero;
				points.Add(potentialPoint);
			}
		}

		void UpdateCollisions()
		{
			for (int i = 1; i < points.Count-1; ++ i) {
				PDB_molecule.BvhSphereCollider collider = new PDB_molecule.BvhSphereCollider(
					molecules[0].mol,points[i].pos,
					0.6f);

				for(int j = 0; j < collider.results.Count; ++j)
				{
					Vector3 atomPos = molecules[0].transform.TransformPoint(molecules[0].mol.atom_centres[collider.results[j].index]);
					float rad = molecules[0].mol.atom_radii[collider.results[j].index];

					float minDist = 0.6f + rad;
					Vector3 normal = points[i].pos - atomPos;
					Vector3 fromMolecule = points[i].pos - molecules[0].transform.position;

					float dist = normal.magnitude;

					normal *= (minDist - dist);
					points[i].force += normal *0.2f;
					points[i].force += fromMolecule *0.4f;
				}
			}
		}

		public override void Update(float dampingFactor, float springFactor, float minDistance)
		{
			int atomIndex1 = atomIds [0];
			int atomIndex2 = atomIds [1];
			Vector3 worldAtomPos1 = molecules [0].transform.TransformPoint (molecules [0].mol.atom_centres [atomIndex1]);
			Vector3 worldAtomPos2 = molecules [1].transform.TransformPoint (molecules [1].mol.atom_centres [atomIndex2]);

			Vector3 dir = (worldAtomPos2 - worldAtomPos1).normalized;
			float distance = (worldAtomPos2 - worldAtomPos1).magnitude;
			if (isActive) {
				if (distance > minDistance) {

					Rigidbody mol1_rb = molecules [0].GetComponent<Rigidbody> ();
					Rigidbody mol2_rb = molecules [1].GetComponent<Rigidbody> ();
				
					// .    .                   .
					// vp = vb + cross(posW, rotV)
					Vector3 atom1Velocity = mol1_rb.GetPointVelocity (worldAtomPos1);
					Vector3 atom2Velocity = mol2_rb.GetPointVelocity (worldAtomPos2);
				
					//Vector3 relativeVelocity1To2 = atom1Velocity - atom2Velocity;
				
					Vector3 damping1 = -dampingFactor * atom1Velocity;
					Vector3 damping2 = -dampingFactor * atom2Velocity;
				
					Vector3 force = new Vector3 (0, 0, 0);
					if (distance > minDistance) {
						force = dir * (distance - minDistance) * springFactor;
						mol1_rb.AddForceAtPosition (force + damping1, worldAtomPos1);
						mol2_rb.AddForceAtPosition (-force + damping2, worldAtomPos2);
					}
				}
			}
			points [0].pos = worldAtomPos1;
			points [points.Count - 1].pos = worldAtomPos2;

			float springLength = (minDistance - distance) / springs.Count;
			if (springLength <= 0) {
				springLength = 0.0001f;
			}
			for(int i = 0; i < springs.Count; ++i)
			{
				springs[i].FixedUpdate(springLength);
			}

			//UpdateCollisions ();

			for(int i = 0; i < points.Count; ++i)
			{
				Vector3 gravity = new Vector3(0,-1,0);
				points[i].force += gravity;
				points[i].FixedUpdate(0.95f);
			}
			
		}

		public override void Draw()
		{
			if (isActive) {

				for(int i=0; i < points.Count; ++i)
				{
					if(i>0)
					{
						Debug.DrawLine(points[i-1].pos,points[i].pos);
					}
				}
			}
		}

	}

	public class Grappel:AtomConnection
	{

		public Grappel(PDB_mesh mol1,PDB_mesh mol2, int at1, int at2): base(mol1,mol2,at1,at2)
		{

		}
		public Grappel()
		{

		}



		public override void Update(float dampingFactor, float springFactor, float minDistance)
		{
			if (isActive) {
				int atomIndex1 = atomIds [0];
				int atomIndex2 = atomIds [1];
				Vector3 worldAtomPos1 = molecules [0].transform.TransformPoint (molecules [0].mol.atom_centres [atomIndex1]);
				Vector3 worldAtomPos2 = molecules [1].transform.TransformPoint (molecules [1].mol.atom_centres [atomIndex2]);

				Vector3 dir = (worldAtomPos2 - worldAtomPos1).normalized;
				float distance = (worldAtomPos2 - worldAtomPos1).magnitude;

				Rigidbody mol1_rb = molecules [0].GetComponent<Rigidbody> ();
				Rigidbody mol2_rb = molecules [1].GetComponent<Rigidbody> ();

				// .    .                   .
				// vp = vb + cross(posW, rotV)
				Vector3 atom1Velocity = mol1_rb.GetPointVelocity (worldAtomPos1);
				Vector3 atom2Velocity = mol2_rb.GetPointVelocity (worldAtomPos2);
			
				//Vector3 relativeVelocity1To2 = atom1Velocity - atom2Velocity;

				Vector3 damping1 = -dampingFactor * atom1Velocity;
				Vector3 damping2 = -dampingFactor * atom2Velocity;

				Vector3 force = new Vector3 (0, 0, 0);
				if (distance > minDistance) {
					force = dir * (distance - minDistance) * springFactor;
				}

				mol1_rb.AddForceAtPosition (force + damping1, worldAtomPos1);
				mol2_rb.AddForceAtPosition (-force + damping2, worldAtomPos2);
			}
		}
		public override void Draw()
		{
			if (isActive) {
				int atomIndex1 = atomIds [0];
				int atomIndex2 = atomIds [1];
				Vector3 worldAtomPos1 = molecules [0].transform.TransformPoint (molecules [0].mol.atom_centres [atomIndex1]);
				Vector3 worldAtomPos2 = molecules [1].transform.TransformPoint (molecules [1].mol.atom_centres [atomIndex2]);

				Debug.DrawLine(worldAtomPos1,worldAtomPos2);
			}
		}
	}
}


