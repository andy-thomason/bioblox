//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
//using System;
using UnityEngine;
using UnityEngine.UI;
using CSG;
using CSGNonPlane;
using CSGFIELD;
using System.Collections;
using System.Collections.Generic;
using System.Linq;


namespace CSG {
    public partial class BigMesh {
        public static int MaxNeighbourDistance = 10;
        public static int MustIncludeDistance = 20;

        /** core filter used to decide if ivert should be included */
        static bool CoreFilter(Vector3 refvert, Vector3 refnorm, Vector3 ivert, Vector3 inorm, float idist) {
            return ((Vector3.Dot((ivert - refvert).Normal(), refnorm) > 0.8
            && Vector3.Dot(inorm, refnorm) > 0
            && idist != int.MaxValue)
            || idist <= MustIncludeDistance);
        }

        private List<int>[] neigh;

        private void baseNeigbourRules() { // find basic neighbour rules (could precompute) ~~~~~~~~~~~~~~~~~~
            if (neigh != null) return;
            neigh = new List<int>[N];
            for (int i = 0; i < N; i++) {
                neigh[i] = new List<int>();
            }
            for (int t = 0; t<triangles.Length; t += 3) {
                int t0 = triangles[t], t1 = triangles[t + 1], t2 = triangles[t + 2];
                // only do in one direction, neighbour triangles wound the other way
                // will do the others, and we don't want to double count
                neigh[t0].Add(t1);
                neigh[t1].Add(t2);
                neigh[t2].Add(t0);
            }
            return;
        }  // END find basic neighbour rules (could precompute) ~~~~~~~~~~~~~~~~~

        private int[] findNeighbours(int bestind, int UseDistance = -1) {
            // find my neighours up to depth UseDistance
            if (UseDistance < 0) {
                UseDistance = MaxNeighbourDistance;
                if (UseDistance < MustIncludeDistance) UseDistance = MustIncludeDistance;
            }
            baseNeigbourRules();

            int[] distFromMe = new int[N];
            List<int>[] idsAtDist = new List<int>[UseDistance + 1];
            for (int i = 0; i < N; i++)
                distFromMe[i] = int.MaxValue;

            // special case dist 0
            idsAtDist[0] = new List<int>();
            idsAtDist[0].Add(bestind);
            distFromMe[bestind] = 0;

            // special case dist 1
            idsAtDist[1] = neigh[bestind];
            foreach (int i in idsAtDist[1])
                distFromMe[i] = 1;

            // compute other distances incrementally
            for (var dd = 2; dd <= UseDistance; dd++) {
                idsAtDist[dd] = new List<int>();
                foreach (int i in idsAtDist[dd - 1]) {
                    foreach (int j in neigh[i]) {
                        if (distFromMe[j] == int.MaxValue) {
                            distFromMe[j] = dd;
                            idsAtDist[dd].Add(j);
                        }
                    }
                }
                if (!idsAtDist[dd].Any())
                    break;
            }

            return distFromMe;

            //string nums = "";
            //for (int i = 0; i <= UseDistance; i++)
            //    nums += " " + idsAtDist[i].Count;
            //GUIBits.Log("neighbour numbers " + nums);
        }

        // generate new mesh from given indices, the first 
        private BigMesh generateNewMesh(int[] newnum, int nn) {
            // and generate new mesh
            Vector3[] nvertices = new Vector3[nn];
            Vector3[] nnormals = new Vector3[nn];
            Vector2[] nuv = new Vector2[nn];
            Color[] ncolor = new Color[nn];
            List<int> ntris = new List<int>();

            for (int i = 0; i < N; i++) {
                int ii = newnum[i];
                if (0 <= ii) {
                    nvertices[ii] = vertices[i];
                    nnormals[ii] = normals[i];
                    nuv[ii] = uv[i];
                    //float dist = (Vector3.Distance(bestvert, vertices[i]) - bestdist) / 10;
                    ncolor[ii] = colors[i];
                    //ncolor[ii] = new Color(1-dist, dist, 1);
                }
            }

            for (int t = 0; t < triangles.Length; t += 3) {
                if (newnum[triangles[t]] >= 0 && newnum[triangles[t + 1]] >= 0 && newnum[triangles[t + 2]] >= 0) {
                    if ((BasicMeshData.Sides & 1) != 0) {
                        ntris.Add(newnum[triangles[t]]);
                        ntris.Add(newnum[triangles[t + 1]]);
                        ntris.Add(newnum[triangles[t + 2]]);
                    }
                    if ((BasicMeshData.Sides & 2) != 0) {
                        ntris.Add(newnum[triangles[t]]);
                        ntris.Add(newnum[triangles[t + 2]]);
                        ntris.Add(newnum[triangles[t + 1]]);
                    }
                }
            }
            return new BigMesh(nvertices, nnormals, nuv, ncolor, ntris.ToArray());

        }


        /** filter according to selected rule 
         * point is a sanple point that should be on or near the surface
         * e.g. might be found by ray hit to the surface itself, or from neighbouring atom centre
         */
        public BigMesh Filter(Vector3 point) {

            // find closest mesh point
            float bestdist = float.MaxValue;
            int bestind = 0;
            for (int i = 0; i < N; i++) {
                float d = Vector3.Distance(point, vertices[i]);
                if (d < bestdist) {
                    bestdist = d;
                    bestind = i;
                }
            }
            // fix point and its normal
            Vector3 bestvert = vertices[bestind];
            Vector3 bestnorm = normals[bestind];
            // bestnorm = new Vector3(0,0,-1);  // temp debug

            int[] distFromMe = findNeighbours(bestind);

            //IList<int> newvertices = new List<int>();
            int[] newnum = new int[N];  // map from old index to new

            int nn = 0;  // new vert number
            float DD = 2;  // offset to get local
            Vector3 refvert = bestvert - bestnorm * DD;
            // now filter out vertices we want
            for (int i = 0; i < N; i++) {
                //     >>>>> core filter here
                if (CoreFilter(refvert, bestnorm, vertices[i], normals[i], distFromMe[i])) {
                    //if ( (Vector3.Dot ((vertices[i] - refvert).Normal(), bestnorm) > 0.8
                    // /   && Vector3.Dot (normals[i], bestnorm) > 0
                    //    && distFromMe[i] != int.MaxValue)
                    //    || distFromMe[i] <= 3) {
                    newnum[i] = nn++;
                } else {
                    newnum[i] = -1;
                }
            }
            BigMesh newmesh = generateNewMesh(newnum, nn);

            //GUIBits.Log("bestvert" + bestvert + " best distance=" + bestdist +
            //" bestnorm" + bestnorm + " vertices=" + nn +
            //" cam forward= " + Camera.main.transform.forward);

            return newmesh;
        }


        /// <summary>
        /// remove all the separated (internal) parts of the surface mesh
        /// find everything connected to vertex 0 (assumed external)
        /// and get rid of the rest.
        /// </summary>
        /// <returns></returns>
        public BigMesh removeSeparated() {
            int[] distFromMe = findNeighbours(0, 9999);

            int[] newnum = new int[N];  // map from old index to new
            int nn = 0;
            for (int i=0; i < N; i++) {
                if (distFromMe[i] != int.MaxValue) {
                    newnum[i] = nn++;
                } else {
                    newnum[i] = -1;
                }
            }

            BigMesh newmesh = generateNewMesh(newnum, nn);
            return newmesh;

        }

        /** find unmatched vertices, indicative of error during mesh generation */
        public Dictionary<Vector2, int> unmatched() {
            // note: do not use Tuple<int,int>, no equality, hash, etc defined, so Dictionary does not work
            Dictionary<Vector2, int> lines = new Dictionary<Vector2, int>();
            // scan counting +ve, -ve */
            for (int t = 0; t < triangles.Length; t++) {
                int v1 = triangles[t];
                int v2 = triangles[ t + ((t % 3 == 2) ? -2 : 1)];
                int s = 1;
                if (v1 > v2) { s = v2;  v2 = v1;  v1 = s;  s = -1;  }
                Vector2 line = new Vector2(v1, v2);
                if (!lines.ContainsKey(line)) lines.Add(line, 0);
                lines[line] += s;
            }

            Dictionary<Vector2, int> badlines = new Dictionary<Vector2, int>();
            foreach (var kvp in lines) {
                if (kvp.Value != 0) {
                    // GUIBits.Log("unmatched line {0}..{1} count={2} {3} {4}", kvp.Key.x, kvp.Key.y, kvp.Value, vertices[(int)kvp.Key.x], vertices[(int)kvp.Key.y]);
                    badlines.Add(kvp.Key, kvp.Value);
                }
            }
            GUIBits.LogK("unmatched#", "{0}", badlines.Count);
            return badlines;
        }

    }  // class BigMesh
} // namespace CSG

// reminder to me: places to stash information in real mesh....
// newmesh.bindposes Matrix4
// newmesh.boneWeights // BoneWeight  (4 int and 4 float)
// newmesh.colors32 // Color32  (32 bits as 4 bytes)
// newmesh.tangents // Vector4
// newmesh.uv, uv2, uv3, uv4 // Vector2


