//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;

namespace CSG {
    using Vector = Vector3;
    using Point = Vector3;


    public static class XRay {
        //public Vector origin, direction;
        //public XRay () {}
        public static float dot(Vector a, Vector b) {
            return Vector3.Dot(a, b);
        }

        public static float fabs(float f) {
            return Mathf.Abs(f);
        }

        public const float SMALL_NUM = 1f - 5;


        // from http://geomalgorithms.com/a06-_intersect-2.html
        // intersect3D_RayTriangle(): find the 3D intersection of a ray with a triangle
        // Original returned reason for non-intersect
        // This version just return float.MaxValue whatever the reason.
        //    Input:  a ray R, and a triangle T
        //    Output: *I = intersection point (when it exists)
        //    Return: intersection parameter
        //    OLD Return: -1 = triangle is degenerate (a segment or point)
        //             0 =  disjoint (no intersect)
        //             1 =  intersect in unique point I1
        //             2 =  are in the same plane
        static float intersect3D_RayTriangle(this Ray R, Vector V0, Vector V1, Vector V2, out Point I) {
            Vector u, v, n;              // triangle vectors
            Vector dir, w0, w;           // ray vectors
            float a, b;              // params to calc ray-plane intersect
            float r = float.MaxValue;
            I = new Point(-99999, -99999, -99999);
            
            // get triangle edge vectors and plane normal
            u = V1 - V0;
            v = V2 - V0;
            n = Vector3.Cross(u, v);              // cross product
            if (n.magnitude == 0)             // triangle is degenerate
                return float.MaxValue; // -1;                  // do not deal with this case
            
            dir = R.direction;              // ray direction vector
            w0 = R.origin - V0;
            a = -dot(n, w0);
            b = dot(n, dir);
            if (fabs(b) < SMALL_NUM) {     // ray is  parallel to triangle plane
                if (a == 0)                 // ray lies in triangle plane
                    return float.MaxValue; // 2;
                else
                    return float.MaxValue; // 0;              // ray disjoint from plane
            }
            
            // get intersect point of ray with triangle plane
            r = a / b;
            if (r < 0.0)                    // ray goes away from triangle
                return float.MaxValue; // 0;                   // => no intersect
            // for a segment, also test if (r > 1.0) => no intersect
            
            I = R.origin + r * dir;            // intersect point of ray and plane
            
            // is I inside T?
            float uu, uv, vv, wu, wv, D;
            uu = dot(u, u);
            uv = dot(u, v);
            vv = dot(v, v);
            w = I - V0;
            wu = dot(w, u);
            wv = dot(w, v);
            D = uv * uv - uu * vv;
            
            // get and test parametric coords
            float s, t;
            s = (uv * wv - vv * wu) / D;
            if (s < 0.0 || s > 1.0)         // I is outside T
                return float.MaxValue; // 0;
            t = (uv * wu - uu * wv) / D;
            if (t < 0.0 || (s + t) > 1.0)  // I is outside T
                return float.MaxValue; // 0;
            
            return r; // 1;                       // I is in T
        }


        public static Vector3 intersect(this Ray ray, Mesh mesh) {
            return ray.intersect(new BigMesh(mesh));
        }

        public static float intersectR(this Ray ray, Mesh mesh) {
            return ray.intersectR(new BigMesh(mesh));
        }

        public static float intersectR(this Ray ray, GameObject gameObject) {
            float bestr = float.MaxValue;
            MeshFilter[] mfs = gameObject.GetComponentsInChildren<MeshFilter>();
            for (int i = 0; i < mfs.Length; i++) {
                Mesh mesh = mfs[i].mesh;
                float r = ray.intersectR(mesh);
                if (r < bestr)
                    bestr = r;
            }

/**
            Mesh mesh = (Mesh)(gameObject.GetComponent<MeshFilter>()).mesh;
            if (mesh != null) 
                bestr = ray.intersectR (mesh);
            Transform trans = gameObject.transform;
            for (int c = 0; c < trans.childCount; c++) {
                GameObject cgo = trans.GetChild (c).gameObject;
                float r = ray.intersectR(cgo);
                if (r < bestr) 
                    bestr = r;
            }
**/            
            return bestr;
        }

        public static Vector3 intersect(this Ray ray, BigMesh mesh) {
            float r = ray.intersectR(mesh);
            if (r == float.MaxValue)
                return new Vector3(float.NaN, float.NaN, float.NaN);
            return ray.origin + r * ray.direction;
        }

        public static float intersectR(this Ray ray, BigMesh mesh) {
            float bestr = float.MaxValue;
            int[] tri = mesh.triangles;
            Vector3[] vert = mesh.vertices;
            Vector3 point = new Point();
            Vector3 bestpoint = new Point(float.NaN, float.NaN, float.NaN);
            float r;
            for (int t = 0; t < tri.Length; t += 3) {
                r = ray.intersect3D_RayTriangle(vert[tri[t]], vert[tri[t + 1]], vert[tri[t + 2]], out point);
                if (r < bestr) {
                    bestr = r;
                    bestpoint = point;
                }
            }
            return bestr;
        }

    }
    // class XRay

}

