//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public class AtomConnection
	{
		public PDB_mesh[] molecules;
		public int[] atomIds;
		public bool isActive;
		public AtomConnection()
		{
			molecules = new PDB_mesh[2] ;
			atomIds = new int[2] ;
			isActive = false;
		}

		public AtomConnection (PDB_mesh mol1,PDB_mesh mol2, int at1, int at2)
		{
			molecules = new PDB_mesh[2] {mol1, mol2};
			atomIds = new int[2] {at1, at2};
			isActive = false;
		}

		virtual public void Update(float dampingFactor, float force, float minDist)
		{}
		virtual public void Draw()
		{}
	}

	public class Grappel:AtomConnection
	{
		float minDist;
		List<Vector3> points;
		List<Vector3> forces;
		public Grappel(PDB_mesh mol1,PDB_mesh mol2, int at1, int at2): base(mol1,mol2,at1,at2)
		{
			Init ();
		}
		public Grappel()
		{
			Init ();
		}

		void Init()
		{

		}

		public override void Update(float dampingFactor, float springFactor, float minDistance)
		{
			if (isActive) {
				minDist=minDistance;
				int atomIndex1 = atomIds [0];
				int atomIndex2 = atomIds [1];
				Vector3 worldAtomPos1 = molecules [0].transform.TransformPoint (molecules [0].mol.atom_centres [atomIndex1]);
				Vector3 worldAtomPos2 = molecules [1].transform.TransformPoint (molecules [1].mol.atom_centres [atomIndex2]);

				Vector3 dir = (worldAtomPos2 - worldAtomPos1).normalized;
				float distance = (worldAtomPos2 - worldAtomPos1).magnitude;

				Rigidbody mol1_rb = molecules [0].GetComponent<Rigidbody> ();
				Rigidbody mol2_rb = molecules [1].GetComponent<Rigidbody> ();

				// .    .                   .
				// vp = vb + cross(posW, rotV)
				Vector3 atom1Velocity = mol1_rb.GetPointVelocity (worldAtomPos1);
				Vector3 atom2Velocity = mol2_rb.GetPointVelocity (worldAtomPos2);
			
				//Vector3 relativeVelocity1To2 = atom1Velocity - atom2Velocity;

				Vector3 damping1 = -dampingFactor * atom1Velocity;
				Vector3 damping2 = -dampingFactor * atom2Velocity;

				Vector3 force = new Vector3 (0, 0, 0);
				if (distance > minDistance) {
					force = dir * (distance - minDistance) * springFactor;
				}

				mol1_rb.AddForceAtPosition (force + damping1, worldAtomPos1);
				mol2_rb.AddForceAtPosition (-force + damping2, worldAtomPos2);
			}
		}
		public override void Draw()
		{
			if (isActive) {
				int atomIndex1 = atomIds [0];
				int atomIndex2 = atomIds [1];
				Vector3 worldAtomPos1 = molecules [0].transform.TransformPoint (molecules [0].mol.atom_centres [atomIndex1]);
				Vector3 worldAtomPos2 = molecules [1].transform.TransformPoint (molecules [1].mol.atom_centres [atomIndex2]);

				Debug.DrawLine(worldAtomPos1,worldAtomPos2);
			}
		}
	}
}


